module GlobalBCs_ml    !u3 Logan_ml
!
!+ DATA/SUBROUTINES FOR USING Logan climatology for BOUNDARY
!  CONDITIONS  (bcs)
! From Hilde's uni.2_Logan_O3 but:
!u3
!  module name changed to GlobalBCs_ml, so that both UiO_ml and
!  public subroutine names changed back:
!        GelLoganData -> GetGlobalData   : UiO and Logan modules
!        (no L suffix now).
!
! Time-of-year, height, and latitude functions applied to non-oozne BCs
! Comments:
!   In using these functions I have had to accept some known problems,
!   for example that the seasonal variation is often weaker at higher
!   altitude. The "vmin" minimum concentration can correct for some
!   of this, but for now (this week) this simplification might be ok.
!   It is after all (I hope) the near-surface BCs which matter most.
!   In principal we could specify al concentrations as complex 3-D fieldds
!   here, but that can wait for the new setup! 
!
! (the private routines, e.g. emeplat2Logan are left as they
!  are since these names are not seen outside this module.
!   -- for use with BoundConditions_ml and My_BoundConditions_ml --
!____________________________________________________________________________

  use GridValues_ml, only: gbacmax,gbacmin,glacmax,glacmin,&
!hf BC
  gl,gb_glob,GlobalPosition

  implicit none
  private
  !/-- subroutines

  public :: GetGlobalData         ! Opens, reads bc_data, closes global data
  public :: setgl_actarray
  
  logical, parameter, private :: DEBUG_Logan = .false.

  ! A. Define parameters and indices of global-model species
  ! ==========================================================================
  !-- definitions in Jostein's grid. Generally, these will be from
  !   a Txx model, where xx is currently 21.

  integer, parameter, public  :: &
        IGLOB = 57 ,   &  ! number of emep 150*150 grids, longitude
        JGLOB = 45        ! number of emep 150*150 grids, latitude


  ! Chemical species:
  ! -- IBC indices text generated by perl script mkp.jost - ds 
  ! ** usually only changed when global-model output changes **

  integer, public, parameter ::  NGLOB_BC  = 12 ! No. species setup here
!u3  integer, public, parameter ::  NLOGAN_BC  = 1 ! No. species in Logans files
!u3 - added : 
  integer, public, parameter :: &
    IBC_O3       =  1   &
   ,IBC_NO       =  2   &
   ,IBC_NO2      =  3   &
   ,IBC_PAN      =  4   &
   ,IBC_HNO3     =  5   &  ! used for nitrate too
   ,IBC_SO2      =  6   &
   ,IBC_SO4      =  7   &
   ,IBC_CO       =  8   &
   ,IBC_C2H6     =  9   &
   ,IBC_C4H10    = 10   &  
   ,IBC_HCHO     = 11   &  
   ,IBC_CH3CHO   = 12  

 !u3 - NEW**
  ! we define some concentrations in terms of sine curves and other
  ! simple data:
 
   type, private :: sineconc   
      real :: surf       ! Mean surface conc. (ppb)
      integer :: dmax    ! Day when concentrations peak
      real :: amp        ! amplitude of surface conc. (ppb)
      real :: hz         ! Scale-height (km) - height to drop 1/e concentration
      real :: vmin       ! background , minimum conc., in vertical direction
      real :: hmin       ! background , minimum conc., in horiz direction
   end type sineconc
   type(sineconc), private, save, dimension(NGLOB_BC) :: SpecBC


! the actual values - do not use IGLOB,JGLOB, but the actual one's
  integer, save, private  :: iglbeg,iglend
  integer, save, private  :: jglbeg,jglend
!  real, save, private     :: stlongact,stlatact

  ! ==========================================================================

contains


  subroutine setgl_actarray(iglobact,jglobact)
 !set actual domain in 150*150 emep coord

  use Par_ml, only:GIMAX,GJMAX,ISMBEG,JSMBEG
  use GridValues_ml, only :i_glob,j_glob

  integer i1
  real hel1,hel2
  integer,intent(out)   :: iglobact,jglobact
    hel1 = (ISMBEG +1.)/3.!global i 150*150 emep coord of start of domain
    hel2 = (ISMBEG+GIMAX)/3.!global i 150*150 emep coord of end of domain
    iglbeg = int(hel1)
    iglend = int(hel2)+1
    iglobact = iglend-iglbeg+1

    hel1 = (JSMBEG+1)/3     !global j 150*150 emep coord of start of domain
    hel2 = (JSMBEG + GJMAX)/3.!global j 150*150 emep coord of end of domain
    jglbeg = int(hel1)
    jglend = int(hel2)+1
    jglobact = jglend-jglbeg+1

    print *,'iglbeg,iglend,iglobact',iglbeg,iglend,iglobact
    print *,'jglbeg,jglend,jglobact',jglbeg,jglend,jglobact


 end subroutine setgl_actarray
 !-------
 !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 subroutine GetGlobalData(month,ibc,used        &
   !u3 subroutine GetGlobalData(month,used        &
                ,iglobact,jglobact,bc_data,io_num,errcode)

  use Io_ml,             only : IO_GLOBBC, ios, open_file
!hf BC
 use ModelConstants_ml, only: KMAX_MID     !u7.4vg, daynumber
 use Dates_ml,   only : daynumber
 use Par_ml,     only : me,NPROC

 !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   !== HANDLES READ_IN OF GLOBAL DATA. We read in the raw data from the
   !   global model, and do the vertical interpolation to EMEP k values
   !   here if the species is to be used.
  !u3 integer   :: iglobact,jglobact
   integer,             intent(in) :: month
   integer,             intent(in) :: ibc    ! Index of BC, u3
   integer,             intent(in) :: used   ! set to 1 if species wanted
   integer,             intent(in) :: iglobact,jglobact !u3 intent added
   real, dimension(iglobact,jglobact,KMAX_MID), &
                       intent(out) :: bc_data   ! Data  from Logan model
   integer,            intent(out) :: io_num    !  i/o number
   integer,          intent(inout) :: errcode   !  i/o number
   logical, save :: my_first_call = .true.      ! u3

   real, dimension(IGLOB,JGLOB,KMAX_MID) :: bc_rawdata   ! Data (was rtcdmp)
!hf BC   real, dimension(IGLOB,JGLOB,ITOP) :: bc_rawdata   ! Data (was rtcdmp)


! Now we want fake data on EMEP 150*150 grid....
!hf BC changes
   integer, dimension(IGLOB,JGLOB), save :: bc_long  !u3  long of 150*150 emep
   integer, dimension(IGLOB,JGLOB), save :: bc_lat   !u3  lat  of 150*150 emep
   integer, dimension(IGLOB), save :: i50  !emep 50*50 coord av emep 150*150 i
   integer, dimension(JGLOB), save :: j50  !emep 50*50 coord av emep 150*150 j
!hf BC   integer, dimension(JGLOB), save :: lat5     !u3  for latfunc below
   integer, dimension(IGLOB,JGLOB), save :: lat5     !u3  for latfunc below

   real, dimension(NGLOB_BC,6:14), save  :: latfunc  !u3  lat. function
   real, save ::  twopi_yr, cosfac   ! for time-variations !u3
   integer :: i, j , k,i1,j1
   real ::val
   character(len=30) :: fname    ! input filename
   integer, save     :: oldmonth = -1  
   io_num = IO_GLOBBC          ! for closure in BoundCOnditions_ml

   errcode = 0

 if ( DEBUG_Logan ) print *, "DEBUG_LOgan ibc, mm", ibc, month

 !u3 - NEW****
 ! ========= first call =========================================
   if ( my_first_call ) then
      ! Set up arrays to contain Logan's grid as lat/long
      !/ COnversions derived from emeplat2Logan etc.:

     twopi_yr = 4.0 * atan(1.0)  / 365.25  ! 2pi/365

!hf BC
   call GlobalPosition  !get gb for global domaib
   do i = 1, IGLOB 
     do j = 1, JGLOB    ! Don't bother with south pole complications
        i50(i)=3*i -1
        j50(j)=3*j -1
        bc_lat(i,j) = gb_glob(i50(i),j50(j)) ! gb is local. Must make global
        lat5(i,j) = bc_lat(i,j)/5      ! lat/5 used in latfunc below
        lat5(i,j) = max(lat5(i,j),6)   ! Min value in latfunc
        lat5(i,j) = min(lat5(i,j),14)  ! Max value in latfunc
        !write(*,*)'LAT5',i,j,i50(i),j50(j),lat5(i,j),bc_lat(i,j)
     end do
   end do

   ! Define concs where a simple  specification based on lat/mm
   ! etc. will be given
   !                           surf   dmax   amp   hz    vmin  hmin !ref
   !                            ppb          ppb   km     ppb   ppb

  SpecBC(IBC_O3   ) = sineconc(-99.9 ,-99.9,-99.9,-99.9 ,-99.9,10.0) !N1  
  SpecBC(IBC_SO2  ) = sineconc( 0.15 , 15.0, 0.05, 100.0, 0.05 , 0.03) !W99
  SpecBC(IBC_SO4  ) = sineconc( 0.15 ,180.0, 0.00, 1.6,  0.05 , 0.03) !W99
  SpecBC(IBC_NO   ) = sineconc( 0.1  , 15.0, 0.03, 4.0  , 0.03, 0.02)
  SpecBC(IBC_NO2  ) = sineconc( 0.1  , 15.0, 0.03, 4.0  , 0.05, 0.04)
  SpecBC(IBC_PAN  ) = sineconc( 0.20 ,120.0, 0.15, 100.0, 0.10, 0.1 )
  SpecBC(IBC_HNO3 ) = sineconc( 0.1  , 15.0, 0.03, 100.0, 0.05, 0.05 )!M
  SpecBC(IBC_CO   ) = sineconc( 125.0, 75.0, 35.0,25.0  , 70.0, 30.0 )!JEJ-W
  SpecBC(IBC_C2H6 ) = sineconc( 2.0  , 75.0, 1.0 , 10.0 , 0.05, 0.05 )
  SpecBC(IBC_C4H10) = sineconc( 2.0  , 45.0, 1.0 , 6.0  , 0.05, 0.05 )
  SpecBC(IBC_HCHO ) = sineconc( 0.7  ,180.0, 0.3 , 6.0  , 0.05, 0.05 )
  SpecBC(IBC_CH3CHO) = sineconc(2.0 ,180.0, 0.5 , 6.0  , 0.05, 0.05 )

 !refs:
 ! N1 - for ozone we read Logan's data, so the only paramater specified
 !      is a min value of 10 ppb. I hope this doesn't come into effect in
 !      Europe as presumably any such min values are in the S. hemisphere.
 !      Still, giving O3 such a value let's us use the same code for
 !      all species.
 !W99: Warneck, Chemistry of the Natural Atmosphere, 2nd edition, 1999
 !    Academic Press. Fig 10-6 for SO2, SO4.
 ! JEJ - Joffen's suggestions from Mace/Head, UiO and other data..
 !      with scale height estimated large from W99, Isaksen+Hov (1987)
 ! M -Mozart-obs comparison

   ! Latitude functions taken from Lagrangian model, see Simpson (1992)
   latfunc(:,6:14) = 1.0   ! default
                            !  30       40        50       60         70 degN
   latfunc(IBC_SO2,6:14) = (/ 0.05,0.15,0.3 ,0.8 ,1.0 ,0.6 ,0.2 ,0.12,0.05/)
   latfunc(IBC_HNO3,6:14)= (/ 1.00,1.00,1.00,0.85,0.7 ,0.55,0.4 ,0.3 ,0.2 /)
   latfunc(IBC_PAN,6:14) = (/ 0.15,0.33,0.5 ,0.8 ,1.0 ,0.75,0.5 ,0.3 ,0.1 /)
   latfunc(IBC_CO ,6:14) = (/ 0.6 ,0.7 ,0.8 ,0.9 ,1.0 ,1.0 ,0.95,0.85,0.8 /)

   latfunc(IBC_SO4,:) = latfunc(IBC_SO2,:)
   latfunc(IBC_NO ,:) = latfunc(IBC_SO2,:)
   latfunc(IBC_NO2,:) = latfunc(IBC_SO2,:)
   latfunc(IBC_HCHO,:) = latfunc(IBC_HNO3,:)
   latfunc(IBC_CH3CHO,:) = latfunc(IBC_HNO3,:)

    my_first_call = .false.

   end if ! my_first_call
 ! ========= end of first call ===================================

!hf BC   if( ibc == IBC_O3 .and. month /= oldmonth ) then    !! Open new file
!month /= oldmonth not needed


  !u3 - NEW - Read ozone for IBC_O3, set for others:
   !+
   !  Specifies concentrations for a fake set of Logan data.
   
   !/-- tmp and crude - we associate 1 km of scaleht with 1 Logan level
   !    - okayish for 1st 5-6 km in any case......

      select case ( ibc )

            case  ( IBC_O3 ) 

              write(unit=fname,fmt="(a6,i2.2)") "ozone.",month
              call open_file(IO_GLOBBC,"r",fname,needed=.true.) 

              if ( ios /= 0 )  then
                call gc_abort (me,NPROC,"BC files module ios error ")
              endif

!              if ( ios /= 0 )  then
!                print *,"BC files module ios error: month,oldmonth ibc ", &
!                         month, oldmonth,  ibc
!                errcode = ios
!                return
!              endif


              read(IO_GLOBBC,*) bc_rawdata

            ! Logan's data has more than 1000 ppb at the higher levels. This
            ! might be correct, but I worry about the ability of our 
            ! advection scheme to cope with huge gradient properly. Hence, 
            ! CRUDE and temporary FIX:
 
              where ( bc_rawdata > 300.0 )
                  bc_rawdata = 300.0 
              end where


!            case   ( IBC_SO2 )
!              write(*,*)'I READ SO2'
!              write(unit=fname,fmt="(a4,i2.2)") "so2.",month
!              call open_file(IO_GLOBBC,"r",fname,needed=.true.) 
!
!              if ( ios /= 0 )  then
!                call gc_abort (me,NPROC,"BC files module ios error ")
!              endif
!
!              read(IO_GLOBBC,*) bc_rawdata


            case ( IBC_NO, IBC_NO2, IBC_HNO3, IBC_CO, &
                     IBC_C2H6, IBC_C4H10, IBC_PAN )

             ! NB since we only call once per month we add 15 days to 
             ! day-number to get a mid-month value

               cosfac = cos( twopi_yr * (daynumber+15.0-SpecBC(ibc)%dmax))

               bc_rawdata(:,:,1) =    SpecBC(ibc)%surf + &
                                       ( SpecBC(ibc)%amp * cosfac)

             !/ - correct for other heights
!hf BC               do k = 2, ITOP
               do k = 2, KMAX_MID
                  bc_rawdata(:,:,k) =   &
                     bc_rawdata(:,:,1)*exp( -(k-1)/SpecBC(ibc)%hz )
               end do
               bc_rawdata = max( bc_rawdata, SpecBC(ibc)%vmin ) 

                     
             !/ - correct for latitude functions --------------------------
!hf BC
               do i = 1, IGLOB
                  do j = 1, JGLOB
!hf BC                  bc_rawdata(:,j,:) = bc_rawdata(:,j,:) * latfunc(ibc,lat5(j))
                     bc_rawdata(i,j,:) = bc_rawdata(i,j,:) * latfunc(ibc,lat5(i,j))
                  enddo
               end do
             !/ - end of correction for latitude functions ---------------

          case ( IBC_SO2, IBC_SO4, IBC_HCHO, IBC_CH3CHO  )
!hf TEST reading so2

!              case ( IBC_SO4, IBC_HCHO, IBC_CH3CHO  )
              ! (No vertical variation for S in marine atmosphere, see W99)
              !  and PAN is just temporary, with some guessing that
              !  since sources decrease with altitude, but lifetime
              !  increases the concs don't change much.

               cosfac = cos( twopi_yr * (daynumber+15.0-SpecBC(ibc)%dmax))

               bc_rawdata(:,:,:) =    SpecBC(ibc)%surf  + &
                                       ( SpecBC(ibc)%amp * cosfac)

             !/ - correct for latitude functions --------------------------
               if ( DEBUG_Logan ) then
                     write(*,*) "LOGAN HORIZ", ibc, SpecBC(ibc)%surf, cosfac
               end if
!hf BC
               do i = 1, IGLOB
                 do j = 1, JGLOB

                  bc_rawdata(i,j,:) = bc_rawdata(i,j,:) * latfunc(ibc,lat5(i,j))
!hf BC                  bc_rawdata(:,j,:) = bc_rawdata(:,j,:) * latfunc(ibc,lat5(j))

                  if ( DEBUG_Logan ) then
                     write(6,"(2i4,f8.2,f15.4)")j, lat5(i,j), &
!hf BC changed
                         latfunc(ibc,lat5(i,j)), bc_rawdata(36,j,1)
                  end if
                 enddo
               end do

             !/ - end of correction for latitude functions ----------------

         case  default
             print *,"Error with specified BCs:", ibc
             errcode = 777
         end select 

   if( DEBUG_Logan ) then

      write(*,"(a15,3i4,f8.3)") "DEBUG:LOGAN: ",ibc, used, month, cosfac
      write(*,*) "LOGAN BC MAX ", maxval ( bc_rawdata ), &
                         " MIN ", minval ( bc_rawdata )
!hf BC      do k = ITOP, 1, -1        ! print out for equator, mid-lat
      do k = KMAX_MID, 1, -1        ! print out for equator, mid-lat
         write(*, "(i4,f12.3)") k,  bc_rawdata(15,15,k)
      end do
   end if ! DEBUG

                     
  !/ - correction for latitude functions -----------------------

   bc_rawdata = max( bc_rawdata, SpecBC(ibc)%hmin ) 

   if( DEBUG_Logan ) write(*,*) "LOGAN NEW MIN", minval ( bc_rawdata )


   if ( used == 1 ) then
 
       !Convert to mixing ratio
       bc_rawdata(:,:,:)=bc_rawdata(:,:,:)*1.0e-9

!hf BC not needed       call vert_interpolation(iglobact,jglobact,bc_rawdata,bc_data)
!hf BC new
!put data only on actual domain

        j1 = 1
        do j = jglbeg,jglend
          i1 = 1
          do i = iglbeg,iglend
   
          bc_data(i1,j1,:) =  bc_rawdata(i,j,:) 
          i1 = i1+1
          enddo
          j1 = j1+1
        enddo


   end if 

 end subroutine GetGlobalData
 !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

end module GlobalBCs_ml   !u3  Logan_ml

!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++





