module UiO_ml
!+ DATA/SUBROUTINES FOR USING Univerity of Oslo CTM DATA AS BOUNDARY
!  CONDITIONS  (bcs)
!
!   -- for use with BoundConditions_ml and My_BoundConditions_ml --
!____________________________________________________________________________
! IMPORTANT NOTE:
! The routines given here are constructed around the global model fields from 
! the University of Oslo (T21) global model. In order to use other models as 
! bcs  then usually these routines will have to be replaced by model-specific 
! routines. The important thing is that the inputs and outputs from the routine
! are independant of the global module used.
!
!  The current version used is the T21 model, supplied by Jostein Sunde, 2000.
!_____________________________________________________________________________
!
! Usage: this module is written to be almost stand-alone, "using" only (!?)
! Io_ml, ModelConstants_ml, Interpolation_ml, and My_Mode_ml. The module can 
! thus be easily used by other codes (e.g. by box models) as long as a set of 
! lat/long data are avaialable. No parallel routines are used.
!
! The main code calls up these routines with just:
!
!  call BoundaryConditions()    , once per month
!  
! The indices for the global model (IBC_..) are assigned here, but these 
! should only change with new verions from UiO or elsehwere.
!
! Module outputs: 
!    indices : sets e.g. IBC_O3,                         ! Global model index
!                        NGLOB_BC                        ! No. BCs
!
! Language : F
! History  :
! ds - December 2000-January 2001: added interpolations, removed txxlat, etc.
! (See !REM at end for removals). Reorganised to keep all UiO stuff here, with
! other routines moved to BoundConditions_ml, My_BoundConditions_ml.
! jej - summer 2000 - original code called globinit.f
! ToDo:
!   enable more flexible update time.
!_____________________________________________________________________________
  implicit none
  private

  !/-- subroutines

  public :: GetGlobalData         ! Opens, reads bc_data, closes global data
  public :: InterpolationFactors  ! Gets factors for interpolation
  public :: setgl_actarray
  
  private :: emeplat2UiO          ! elemental function to convert coordinates
  private :: emeplong2UiO         ! elemental function to convert coordinates
  private :: emeplat2UiOact          ! elemental function to convert coordinates
  private :: emeplong2UiOact         ! elemental function to convert coordinates
  private :: vert_interpolation ! sets vertical weighting factors for interpolations

  logical, parameter, private :: DEBUG_UiO = .false.

  ! A. Define parameters and indices of global-model species
  ! ==========================================================================
  !-- definitions in Jostein's grid. Generally, these will be from
  !   a Txx model, where xx is currently 21.

  integer, parameter, public  :: &
        IGLOB = 64 ,   &  ! number of zonal grids
        JGLOB = 32 ,   &  ! number of latitudinal grids
        ITOP  = 19        ! number of vertical grids


  real, parameter, private ::    &
         STLONG = 0.        &  ! western side of longitude # 1
       , STLAT  = -90.0 + 90.0/JGLOB   &  ! southern extent of latitude # 1
       , LATINC  = 180.0/JGLOB   &  ! latitude increment of UiO grid
       , LONGINC = 360.0/IGLOB      ! longitude increment of UiO grid



  ! Chemical species:
  ! -- IBC indices text generated by perl script mkp.jost - ds 
  ! ** usually only changed when global-model output changes **

  integer, public, parameter ::  NGLOB_BC  = 51 ! No. species in Jostein's file

  integer, public, parameter :: &
   IBC_O3       =  1, IBC_NOX      =  2, IBC_HNO3     =  4, IBC_PANX     =  5 &
 , IBC_CO       =  6, IBC_C2H4     =  7, IBC_C2H6     =  8, IBC_C3H6     =  9 &
 , IBC_C4H10    = 10, IBC_C6H14    = 11, IBC_C6HXR    = 12, IBC_CH2O     = 13 &
 , IBC_CH3CHO   = 14, IBC_H2O2     = 15, IBC_CH3O2H   = 16, IBC_HO2NO2   = 17 &
 , IBC_CH3COY   = 18, IBC_CH3COX   = 19, IBC_ISOPRENE = 20, IBC_HO2      = 21 &
 , IBC_CH2O2OH  = 26, IBC_CH3COB   = 27, IBC_CH3XX    = 28, IBC_AR1      = 29 &
 , IBC_AR2      = 30, IBC_AR3      = 31, IBC_ISOR1    = 32, IBC_ISOK     = 33 &
 , IBC_ISOR2    = 34, IBC_HCOHCO   = 35, IBC_RCOHCO   = 36, IBC_CH3X     = 37 &
 , IBC_NO3      = 41, IBC_N2O5     = 42, IBC_NO       = 43, IBC_NO2      = 44 &
 , IBC_CH4      = 46, IBC_C3H8     = 48, IBC_C3H7O2   = 49, IBC_ACETONE  = 50 
  !/ cont...
  integer, public, parameter :: &
   IBC_CH3COD   = 51, IBC_NOZ      =  3, IBC_CH3O2    = 22, IBC_C2H5O2   = 23 &
 , IBC_C4H9O2   = 24, IBC_C6H13O2  = 25, IBC_O3P      = 38, IBC_O1D      = 39 &
 , IBC_OH       = 40, IBC_O3NO     = 45, IBC_DMS      = 47

!        now the actual values - do not use IGLOB,JGLOB, but the actual one's
  integer, save, private  :: iglbegw,iglbege,iglendw,iglende
  integer, save, private  :: jglbeg,jglend
  real, save, private     :: stlongact,stlatact

  ! ==========================================================================

contains


   subroutine setgl_actarray(iglobact,jglobact)
  use GridValues_ml, only: gbacmax,gbacmin,glacmax,glacmin

  integer i1
  real hel1,hel2
  integer   :: iglobact,jglobact

        hel1 = emeplong2UiO(glacmin)
        hel2 = emeplong2UiO(glacmax)
        if(glacmin<STLONG)then
          iglbegw = int(hel1)
          stlongact = STLONG+(iglbegw-1)*LONGINC-360.
          if(glacmax.ge.STLONG)then
            iglendw = IGLOB
            iglbege = 1
            iglende = int(hel2)+1
            iglobact = IGLOB-iglbegw+iglende+1
          else
            iglendw = int(hel2)+1
            iglbege = 1
            iglende = -1
            iglobact = iglendw-iglbegw+1
          endif
        else
          iglbegw = 1
          iglendw = -1
          iglbege = int(hel1)
          iglende = int(hel2)+1
          iglobact = iglende-iglbege+1
          stlongact = STLONG+(iglbege-1)*LONGINC
        endif
        hel1 = emeplat2UiO(gbacmin)
        hel2 = emeplat2UiO(gbacmax)
        jglbeg = int(hel1)
        jglend = int(hel2)+1
        if(jglend.gt.JGLOB)jglend=JGLOB
        jglobact = jglend-jglbeg+1
        stlatact = STLAT+(jglbeg-1)*LATINC

        print *,'iglbegw',iglbegw,iglendw,stlongact
        print *,'iglbege',iglbege,iglende,iglobact
        print *,'jglbeg',jglbeg,jglend,jglobact,stlatact
  

 end subroutine setgl_actarray
 !-------
 !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   subroutine GetGlobalData(month,used        &
                ,iglobact,jglobact,bc_data,io_num,errcode)

  use Io_ml,                     only : IO_JOST, ios, open_file
  use ModelConstants_ml, only:     &
           KMAX_MID                     ! K-value at ground

 !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   !== HANDLES READ_IN OF GLOBAL DATA. We read in the raw data from the
   !   global model, and do the vertical interpolation to EMEP k values
   !   here if the species is to be used.
  integer   :: iglobact,jglobact
   integer,             intent(in) :: month
   integer,             intent(in) :: used   ! set to 1 if species wanted
   real, dimension(iglobact,jglobact,KMAX_MID), &
                       intent(out) :: bc_data   ! Data  from UiO model
   integer,            intent(out) :: io_num    !  i/o number
   !ds-odin integer,            intent(out) :: errcode    !  i/o number
   integer,            intent(inout) :: errcode    !  i/o number

   real, dimension(IGLOB,JGLOB,ITOP) :: bc_rawdata   ! Data (was rtcdmp)

   character(len=30) :: fname    ! input filename
   integer, save     :: oldmonth = -1  
   io_num = IO_JOST              ! for closure in BoundCOnditions_ml

   errcode = 0
   if ( DEBUG_UiO ) print *, "TTTT in GetGlobalData months are: ", month, oldmonth

   if( month /= oldmonth ) then    !! Open new file

      write(unit=fname,fmt="(a6,i2.2,a4)") "gl_ass",month,".dat"
      call open_file(IO_JOST,"r",fname,needed=.true.) 

      if ( ios /= 0 )  then
        print *,"ios error: gl_ass"
        errcode = ios
        return
      endif
      oldmonth = month

   end if 


   !u1 Feb 2002 - changed to new UiO values
   !u1 read(IO_JOST,"(2P10E12.4)") bc_rawdata
   read(IO_JOST,"(10E12.4)") bc_rawdata

   if ( used == 1 ) then
         call vert_interpolation(iglobact,jglobact,bc_rawdata,bc_data)
   end if 

 end subroutine GetGlobalData

 !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 subroutine vert_interpolation(iglobact,jglobact,bc_rawdata,bc_data)

  use ModelConstants_ml, only:     &
           KMAX_MID                   &  ! K-value at ground
          ,PT                         ! Top of EMEP model (=1.0e4 Pa)
  use GridValues_ml, only: sigma_mid    ! EMEP sigma values

 !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 !+
 ! Calculates interpolation from global-model sigma to EMEP model sigma. If
 ! sigma in emep model is greater than sigma in lowest layer in global model,
 ! concentrations frm the lowest global layer are used. 
 !    This routine  is run every time new bc data are read
 ! in. We could save the interpolation factors, but the calculations are
 ! trivial so we don't bother.
 !--------------------------------------------------------------------------

  integer   :: iglobact,jglobact
   real,  dimension(IGLOB,JGLOB,ITOP), intent(in)  :: bc_rawdata !  data 
   real,  dimension(iglobact,jglobact,KMAX_MID), intent(out) :: bc_data    !  data 

   logical, save                    :: my_first_call = .true.
   integer, dimension(KMAX_MID), save  :: kglob1, kglob2    !  k-levels from global model
   real,    dimension(KMAX_MID), save  :: c   ! Interpolation factor

   real, dimension(ITOP+1) ::  &
         pres                &! pressure levels in glob. model
        ,gsigma              &! sigma levels in glob. mod.
        ,mygsig               ! glob sigma conv. to PARLAM ps sigma

   real ::  midsiga     &  ! global sigma value centered imediately above..
        , midsigb        ! global sigma value centered imediately below..

   real    ::  a, b       ! help variables
   integer ::  k, kg, ish ! help variables
        integer i,j,i1,j1

  real, parameter :: &  
          PSURF = 1013.0      &  ! surface pressure 1013 hPa
        , PTG   =    1.0      &  ! pres. at top of the global model    ( mb)
        , PTM   = PT/100.0       ! --------"-------    PARLAM/eulmod   ( mb)


   if ( my_first_call ) then
      !-consistency check
!       if ( size(bc_rawdata,1) /= size(bc_data,1) .or. &
!           size(bc_rawdata,2) /= size(bc_data,2) .or. &
!       if ( size(bc_rawdata,3) /= ITOP .or. &             
!           size(bc_data,3)    /= KMAX_MID ) then
!         call stop_all("ERROR: Mis-match in verical interpolation arrays")
!       end if

       pres = (/  &
        996.0, 983.0, 955.0, 909.0, 846.0, 769.0, 682.0, 589.0, 495.0, 406.0, &
        323.0, 251.0, 190.0, 141.0, 103.0,  73.0,  50.0,  30.0,  10.0,   1.0  /)

 !/1.  convert the sigma values from the global model ( gsigma ) 
 !     the definition of sigma ( mygsig ) used in eulmod.

       gsigma(ITOP+1) = 0.0
       gsigma(1:ITOP) = pres(1:ITOP)/pres(1)

       a = (PSURF - PTG)/(PSURF - PTM)
       b = (PTG - PTM)/(PSURF - PTM)
       mygsig(1:ITOP+1) = gsigma(1:ITOP+1)*a + b


 !/2. - set up vertical interpolation factors, c, plus coordinate indices 
 !      kglob,ish

        kg = 1
        do k = KMAX_MID,1,-1    ! size = KMAX_MID
            midsiga  = 0.5 * (mygsig(kg) + mygsig(kg+1))
            if(sigma_mid(k) <  midsiga) then
                kg = kg +1
                midsigb = midsiga
                midsiga = 0.5 * (mygsig(kg) + mygsig(kg+1))
            end if
            if(kg == 1) then      
                ish  = 0
                c(k) = 1
            else
                ish  = -1
                c(k) = (midsigb-sigma_mid(k))/(midsigb - midsiga)
            end if
  
            kglob1(k) = kg       ! Sets global k-coordinate corresponding to k
            kglob2(k) = kg+ish   ! Sets global k-coordinate corresponding to k(-1)

            if ( DEBUG_UiO ) then
                 print "(a25,2i4,4f8.3,2i3,2f8.4)",  &
                     "UiO_ml: VERTICAL GRID DEFS: k, kg1, kg2",&
                      k, kg, mygsig(kg), mygsig(kg+1),midsiga, midsigb, &
                      kglob1(k), kglob2(k), sigma_mid(k), c(k)
            end if 
        end do ! k
     end if  ! my_first_call
     !=======================
     my_first_call = .false.
     !=======================

     do k = 1,KMAX_MID
        j1 = 1
        do j = jglbeg,jglend
          i1 = 1
          do i = iglbegw,iglendw
   
          bc_data(i1,j1,k) =  c(k) * bc_rawdata(i,j,kglob1(k)) +  & 
                       (1.0-c(k))* bc_rawdata(i,j,kglob2(k))
          i1 = i1+1
          enddo
          do i = iglbege,iglende
          bc_data(i1,j1,k) =  c(k) * bc_rawdata(i,j,kglob1(k)) +  & 
                       (1.0-c(k))* bc_rawdata(i,j,kglob2(k))
          i1 = i1+1
          enddo
          j1 = j1+1
        enddo
     end do ! k
       

 end subroutine vert_interpolation
 !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 subroutine InterpolationFactors(gb,gl,ixp,iyp,wt_00, wt_01, wt_10, wt_11)
 !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 !+
 ! Calculates interpolation factors to get from global-model sigma to
 ! EMEP model sigma, and also calculates ibc(i,j), jbc(i,j), which are the 
 ! global-model coordinates corresponding to the input emep i,j coordinates.
 !
 ! Interpolation factors: are with respect to the 4 nearest
 ! points in space.  wt_ij is the weight to be attached to point (i,j) 
 ! relative to the bottom left-hand corner point: 
 !
 ! Note on domains: although the geograaphical stuff has been specified
 ! for the whole MAXLIMAX,MAXLJMAX grid, the interpolations take time
 ! and are only needed for sub-domain actually used, i.e. for limax, ljmax,
 ! which we get fromt he size of the ixp arrays.
 !--------------------------------------------------------------------------
  use Par_ml,   only : MAXLIMAX, MAXLJMAX
  use Functions_ml, only: bilin_interpolate  ! bilinear interpolation

 real, dimension(MAXLIMAX, MAXLJMAX), intent(in) :: gb, gl      ! emep-model lat, long 

 integer, dimension(MAXLIMAX, MAXLJMAX), intent(out):: &
          ixp, iyp  ! emep (i,j) in integer global model coordinates

 real, dimension(MAXLIMAX, MAXLJMAX), intent(out) :: wt_00, wt_01, wt_10, wt_11 ! See above

 !/ variables used in interpolation routine:

 real, dimension(MAXLIMAX, MAXLJMAX) :: x, y  ! global model coordinates

 real    ::  sumwt           ! help variable
 integer ::  i, j

    !/ consistency check
!    if ( size(wt_00,1) /= size(gb,1) .or. size(wt_00,2) /= size(gb,2) ) &
!        call stop_all("ERRROR: size mis-match in InterpolationFactors")

!    forall (i=1:size(ixp,1), j=size(ixp,2) )
!    forall (i=1:MAXLIMAX, j=1:MAXLJMAX )
        do j=1,MAXLJMAX
        do i=1,MAXLIMAX
        x(i,j) = emeplong2UiOact(gl(i,j))
        y(i,j) = emeplat2UiOact(gb(i,j))
        enddo
        enddo
!    end forall

    !============================================================
    call bilin_interpolate(x,y,ixp,iyp,wt_00,wt_01,wt_10,wt_11)
    !============================================================

     if ( DEBUG_UiO ) then 
        print *, "UiO after interpolation : "
        do j = 1,size(ixp,2), 10
           do i = 1,size(ixp,1), 10
             sumwt =   wt_00(i,j) + wt_01(i,j) + wt_10(i,j) + wt_11(i,j)
             print "(a5,2i4,4f8.3,2i5,4f8.3,f12.3)",  "wts: ",            &
                 i,j,gl(i,j), gb(i,j), x(i,j), y(i,j),ixp(i,j),iyp(i,j),  &
                  wt_00(i,j),wt_01(i,j),wt_10(i,j),wt_11(i,j), sumwt
           end do
         end do
      end if
   
 end subroutine InterpolationFactors
 !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

 elemental function emeplat2UiO(lat) result (y)
 ! Converts input latitude to UiO y-coordinate
   real, intent(in) :: lat
   real :: y
      y = (lat-STLAT)/LATINC + 1.0
 end function emeplat2UiO
 !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

 elemental function emeplong2UiO(long) result (x)
 ! Converts input longitude to UiO x-coordinate
   real, intent(in) :: long
   real :: x
   real :: lon2    ! dummy longitude (can't change intent(in) value)
      lon2 = long
      if ( lon2 < STLONG ) lon2 = lon2 + 360.0
      x = (lon2-STLONG)/LONGINC + 1.0
 end function emeplong2UiO
 !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

 elemental function emeplat2UiOact(lat) result (y)
 ! Converts input latitude to UiO y-coordinate
   real, intent(in) :: lat
   real :: y
      y = (lat-stlatact)/LATINC + 1.0
 end function emeplat2UiOact
 !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

 elemental function emeplong2UiOact(long) result (x)
 ! Converts input longitude to UiO x-coordinate
   real, intent(in) :: long
   real :: x
      x = (long-stlongact)/LONGINC + 1.0
 end function emeplong2UiOact
 !>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
end module UiO_ml

!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! Removed:
!REM integer, dimension(:,:) :: ibc,jbc    ! was ixn, jxn
!REM  real    ::  glij, sumwt !! , x, y, wt_00, wt_01, wt_10, wt_11 ! help variables
!REM  real, dimension(IGLOB+1)  ::  txxlong ! global txx longitudes
!REM  real, dimension(JGLOB+1)  ::  txxlat  ! global txx latitudes
!REM  integer ::  i, j, lat, long, ig, jg      !   "    "
!REM 
!REM  !/2. txxlat -- latitudinal boundaries for the txx global grid, where JGLOB is
!REM  !           the number of latitudinal grid points. ( JGLOB = 32 )
!REM  
!REM    txxlat(1)   = STLAT 
!REM    do lat = 2, JGLOB+1
!REM        txxlat(lat) = txxlat(lat-1) + LATINC
!REM    end do 
!REM 
!REM 
!REM  !/3.   txxlong  -- evenly spaced longitudinal boundaries where IGLOB is the
!REM  !               number of longitudinal grid points. ( IGLOB = 64 - t21 grid)
!REM  
!REM    txxlong(1) = STLONG
!REM    do long = 2,IGLOB+1
!REM       txxlong(long) = txxlong(long-1) + LONGINC
!REM    end do
!REM 
!REM 
!REM  !/4. Calculate ibc(i,j), jbc(i,j), which are the global-model coordinates 
!REM  !    corresponding to the input emep i,j coordinates.
!REM  !sunew
!REM  !  -ds - some do loops re-written to conform with  F.
!REM 
!REM    jg = 1
!REM    do j = 1,DIMY
!REM      do i = 1,DIMX
!REM 
!REM         do 
!REM           if ( gb(i,j) >  txxlat(jg) ) exit
!REM           jg = jg-1
!REM         end do
!REM 
!REM         do 
!REM           if ( gb(i,j) <=  txxlat(jg+1) ) exit
!REM           jg = jg+1
!REM         end do
!REM         jbc(i,j) = jg
!REM 
!REM         glij = gl(i,j)
!REM         if( glij <= txxlong(1) ) glij = glij + 360.0
!REM         ig = int( (glij-txxlong(1)) / LONGINC) + 1
!REM         if( glij == txxlong(ig) ) ig = ig + 1
!REM         ibc(i,j) = ig
!REM 
!REM         print *, "TTT HOR", i, j, gl(i,j), gb(i,j), ibc(i,j), jbc(i,j)
!REM      end do
!REM    end do
!REM   !sunew
