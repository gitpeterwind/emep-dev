\chapter{Programming rules and tips}


The mixed FORTRAN'77 - FORTRAN'90 code of the earlier models
has been extensively replaced by pure FORTRAN'90. The biggest change
is in the use of modules instead of include-files and common blocks
to share data and subroutines between different parts of the model.
One advantage of mouldes is that it allows the explicit statement
of thre variables which are being used. Thus, 

\begin{verbatim}
use PhysicalConstants_ml, only : KARMAN
\end{verbatim}

\noindent
lets the reader know where the variables KARMAN is coming from, without
having to trudge through many thousand lines of `include' files.


Modules also give the compiler much more information on the 
arguments to subroutines and dimensions of arrays. All of this
helps to minimise errors in the code.


\section{Timing the Code}

{\bf module My\_Timing\_ml}\\

  
\noindent
This module may be used to collect information on either system time or
 CPU time. Calling Code\_timer from the external routines is the standard
 interface. If system time is required then modify Code\_timer to
 use system\_clock, and declare the time variables (tim\_before, tim\_after, etc.)
 as integers. If CPU time is required modify Code\_timer to call 
 CPU\_TIME and declare the time variables as real.
\bigskip

\noindent
Note:\\
 Code commented out or marked with !SYS is intended for system\_clock\\
 Code commented out or marked with !CPU is intended for cpu\_time\\


The procedure used to switch between these modes is a bit crude - the good
old `comment out what you don't need' approach, but is clearly marked.
The reasoning for the crude approach is simplicity. Since it is not anticipated
that switching between system time and CPU time will occur often, it is
ok to let the user do this work when required. Further, system time needs
integer arguments, whereas cpu-time needs real numbers, so a flexible
approach would get either messy ot long-winded. Who needs that.


The general procedure to add timing  around a couple of pieces of code looks like
this:

  \begin{verbatim}

      call Code_timer(tim_before)     ! Initialises the first tim_before

      ... Bit of very interesting fortran code

      call Add_2timing(10,tim_after,tim_before, "Time for this bit")

       call chemistry

      call Add_2timing(11,tim_after,tim_before, "Time for chemistry")

  \end{verbatim}


See the module for more details. The times and text descriptions are stored
in arrays and printed out with Output\_timing. 



\section{Stop!!!}

{\bf stop\_test, in module My\_Runmode\_ml.F90}\\

The good-old Fortran `stop' should not be used on
parellel computers, as it stops only the processor which called  it,
rather than the whole run. 


The subroutine {\bf gc\_abort} is used to allow for
different methods of stopping the code on different
computers.  



\section{print versus write}

The {\bf write} command uses buffered output and does not slow down the code
very much. A disadvantage is that a code-crash  may occur after a write-statement, but
the output may be lost anyway.

The {\bf print} command is unbuffered, and so is good for placing just before crashes.
It really slows down the code though. Use only in cases where something has gone
wrong and output is needed immediately. A good example is just before a
{\bf gc\_abort} call to provde extra information.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{The rules}

Well, there aren't many, but just a few which will help to keep
the code clean and easy I hope:

\begin{enumerate}
\item
    Document carefully !!!!
    Write the code assuming that the next person to work with it will
    be there long after you are gone, is fairly new to programming,
    and very new to this model. In many cases this assumption will
    be fulfilled!
\item
    For subroutine arguments, use the {\tt intent} attribute always.
    This is a great aid for the compiler and the reader!
\item
    Use UPPER CASE for PARAMETERS, lower case for other variables.
    Should keep C-programmers happy also.
\item
    Use variable-names which are descriptive! Do not try to save
    typing by omitting vowels! Thus, w d nt wrt lk ths, but rather
    we write like this.
\item
    Remember, longer-names are also easier to search for. Thus,
    ``grep GRAV *.f*'' will now give a useful listing of the places where
    gravity occurs, whereas ``grep g *.f*'' will produce a rather longer 
    and less useful output. Easier to find in vi or emacs too.
\item Modules 1.
    Much of the code is in modules. Access variables and routines with
    the {\bf use only} construct as far as possible - this makes it
    easier to spot where variables are coming from and is safer.
\item Modules 2.
    Put all {\bf use only} constructs at the top of each module, rather than
    at the top of each subroutine or function within the module. This makes
    it easy to get an overview of the module dependencies.
\item
     Use $<$ and $>$ instead of $.lt.$ and $.gt.$. Clearer and shorter!
\item
    Don't use lines which are longer than 78 characters. These wrap
    around and tend to mess up your nicely formatted and indented code :-)
\item
    Use spaces rather than tabs, also for simple formatting reasons.
    Tabs don't print out the same on all computers/printers.
\item
    Try to code `module-oriented'. The modules should be individual
entities; Your routines should still behave properly after any
modification of other parts of the code.  Conversely: it should be
possible to modify your routine without having to change also other
parts of the code.

However this rule is much more difficult to apply than the other rules :-(


\item
    Do not use ``l'' or ``ll'' as variable names - they are too easily
    confused with 1 and 11 in print-outs. 
\item
    Do you still remember rule 1?
\end{enumerate}




