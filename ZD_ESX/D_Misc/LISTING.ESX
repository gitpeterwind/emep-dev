esx_tester.f90 xxxxxxxxxxxxxxxxxxxxxxxxxxx
 175  683 5800 ../esx_tester.f90
 
program tester
  use AllocInits,       only : AllocInit
  use ChemSpecs,        only : NSPEC_TOT, define_chemicals
  use CheckStops,       only : CheckStop
  use esx_gleaf,        only : config_DO3SE, DO3SE_gleaf, DO3SE_conf => conf
  !use esx_GetData,  only : GetMetData
  use esx_ZdiffSolver,  only : ZdiffSolver
  use esx_ChemRun,      only : ChemRun
  use esx_Zchem,        only : init_zchem, xChem
  use esx_Zmet,         only : init_zmet
  use esx_Zgrid,        only : init_zgrid
  use esx_Zveg,         only : Config_Zveg, init_Zveg, Set1dVeg
  use esx_Variables,    only : Config_esx, esx, Zmet
  use Io_ml,            only : IO_LOG
  use Io_Routines,      only : writetdata
  use SmallUtils,       only : find_index

  implicit none

  character(len=100) :: msg = "ok", filename, sname
  real :: Vd=0.0, Ve=0.0  ! defaults for testing
  real :: ppb
  integer :: i,idspec, icspec, nprint
  logical :: first=.true.
  integer :: config_io
  integer :: nz, nDiffSpecs, nOutSpecs, nteval

  !> Helper(or fake) arrays
  real, allocatable, dimension(:) :: cz  ! concs in 1-D column

  ! zeroth and 1st order source sink for Crank-Nichiolson, not used so far
  real, allocatable, dimension(:) :: SourceSink0, SourceSink1

  !> czprint Array stores results for printing/plotting
  real, allocatable, dimension(:,:,:) :: czprint  !(nz,nDiffSpecs,nteval)

  !> Check that compilation flags give higher precision
  call CheckStop(digits(1.0)<50, &
     "COMPILED WRONGLY: Need double precision, e.g. gfortran -fdefault-real-8")

  !/ Initialise and configure
  call define_chemicals()

  open (newunit=config_io, file="config_esx.nml")

   call Config_esx(config_io, writelog=.true.)   !> Sets esx%nz, etc.

   call init_Zgrid()                             !> esx%nz, esx%z, etc, ..

   call config_Zveg(config_io, writelog=.true.)  !> Sets Zveg%zbnd, etc.
 
   !> Reads config file, and allocates chemical arrays xChem, rcemis etc.

   call init_Zchem(config_io, debug_level=esx%debug_Zchem )

   if( esx%uses_do3se) call config_DO3SE(config_io)

  close (config_io)

  !/ Some output files:
  open (newunit=IO_LOG, file="Log.esxtester")

  nz         = esx%nz
  nDiffSpecs = esx%nDiffSpecs
  nOutSpecs  = esx%nOutSpecs
  nteval = maxloc(esx%printTime,dim=1)    ! Number of print-out times
  print "(a,i4, ' zmax=',f8.2,' nt=',i6)", "CONF Z", nz, esx%z(nz), nteval

  call AllocInit( czprint,     0.0, nz,nOutSpecs,nteval, "czprint")
  call AllocInit( cz,          0.0, nz, "cz")
  call AllocInit( SourceSink0, 0.0, nz, "SS0")
  call AllocInit( SourceSink1, 0.0, nz, "SS1")

  call init_Zveg() !> dLAI, cumLAI, => LogLAIz.txt output

  call init_Zmet()       !> temp (tzK), rhz, Kz,

  if( esx%uses_do3se) call DO3SE_gleaf() !SKIP for now


  ! testing
   if( index( esx%exp_name, "an_sol_c")>0) then
     xChem( :, : ) = 0.0
     xChem( :, 1 ) = 1.0/esx%dz(1) ! unit initial source at surface
     print *, trim(esx%exp_name), " FORCES UNIT SOURCE", xChem( 1, 1 )
   end if
  
   nprint = 1 
   ppb = 1.0e9/Zmet(1)%M   !! ppb at surface
   do i = 1, nOutSpecs
     icspec = esx%OutSpecs(i)%int
     czprint(:, i , nprint) = xChem(icspec,:)*ppb
   end do
   nprint = nprint + 1

!/ Solve 

  associate(t => esx%Time, tmax => esx%endTime, &
            dt=>esx%dt_phychem, tprint=>esx%printTime)

   !> Update veg PAR, gs etc if needed: (move inside time-loop soon)

    if( esx%uses_veg) call Set1dveg(printflag=.true. )

    TIMELOOP: do while (t <= tmax)
      t = t + dt

      if( esx%debug_driver > 0 ) write(*,"(a,g15.3)") "TLOOP", t


      !> CHEMISTRY ======================================:
      !> The chemical scheme includes any emission terms, tyically
      !! the main cause of  fast production/loss in the ESX system
      !! (and also of strong vertical gradients)

      if( esx%uses_chem) call ChemRun( dt, esx%debug_Zchem )

      !> DISPERSION =====================================:
      !! Here we include only those species specified in
      !! esx%DiffSpecs arrays

      if( esx%uses_diff) then

         DIFFSPECS: do idspec = 1, nDiffSpecs !> LOOP OVER DISPERSING SPECIES
            icspec = esx%DiffSpecs(idspec)%int
            cz(:) = xChem( icspec, : )

           
         call ZdiffSolver(nz, dt, Vd,Ve, Fb=0.0, Ft=0.0, &
            D=SourceSink1, E=SourceSink0, concn=cz, fixedBC=.true., &
            debug_level=esx%debug_Zdiff )

            xChem(icspec,:) = cz(:)

         end do DIFFSPECS
      end if 

      !! Store for print out if needed
      if ( t>0.0 .and. abs( t-tprint(nprint)) < 1.0e-3 ) then !! Store output
          ppb = 1.0e9/Zmet(1)%M   !! ppb at surface
          do i = 1, nOutSpecs
            icspec = esx%OutSpecs(i)%int
            sname  = esx%OutSpecs(i)%key
            print "(a,2i3,f8.2,i4,es12.3)", "CZPRINT " // trim(sname), &
                 nprint,  i, t, icspec, xChem(icspec,1)*ppb
            czprint(:, i , nprint) = xChem(icspec,:)*ppb
          end do
          nprint = nprint + 1
      end if


      first = .false.

      !> CHEMISTRY ============================


    end do TIMELOOP

    do i = 1, nOutSpecs !> Output to files
       icspec = esx%OutSpecs(i)%int
       sname  =trim(esx%OutSpecs(i)%key )
       filename="Results_"//trim(esx%exp_name) // "_" // trim(sname ) // ".txt"
       call writetdata(filename,  tprint, esx%z(1:nz),  czprint( :,i, 1:nprint-1) )

       if ( esx%uses_plotting) then 
         write(msg,"(9a)") " -i ", trim(filename), " ", trim( esx%plot_flags ), " -c "//trim(sname)
         print *, "Plot flags =", trim(msg), " -c " 
         call system("cat "//trim(filename) )
         call system("D_Plotting/plotZarray.py "//trim(msg))
       end if
    end do
  end associate

end program tester
! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !
 
esx_Zgrid.f90 xxxxxxxxxxxxxxxxxxxxxxxxxxx
  85  268 2646 ../esx_Zgrid.f90
 

!>   Definition of z-layer variables, e.g. dzmid, 

module esx_Zgrid
  !use ModelConstants, only: dp
  use esx_Variables, only:  esx

  implicit none
  private

  public ::  init_Zgrid   !> allocates arrays for  z values
  public ::  test_Zgrid   !> tests subroutines in this module

 contains

  !----------------------------------------------------------------------------
  subroutine init_Zgrid()

    integer :: nz
    real, pointer, dimension(:) :: z, dz, zbnd, dzmid

    esx%nz = maxloc(esx%zbnd,dim=1)
    nz     = esx%nz
print *, "NZ ",nz !!, " ZIN:", zin

    z => esx%z(1:nz)
    dz => esx%dz(1:nz)
    zbnd => esx%zbnd(1:nz)
    dzmid => esx%dzmid(1:nz)

!ORIG    z(:)       = zin(:)
!ORIG    zbnd(1:nz-1) = (z(1:nz-1)+z(2:nz))/2    !z_i+½ = (z_i + z_i+1)/2

    !zbnd(:)       = zin(:)
    z(1)    = 0.5*zbnd(1)                           !
    z(2:nz) = (zbnd(1:nz-1)+zbnd(2:nz))/2           !z_i+½ = (z_i + z_i+1)/2
 
    !ORIG dz(2:nz-1) = zbnd(2:nz-1)-zbnd(1:nz-2)  !dz_i = z_i+½ - z_i-½
    !ORIG dz(nz)   = 2*( z(nz)-zbnd(nz-1) )       !dz_n+1 = 2( z_n - z_n-½ )

    dz(1)    = zbnd(1)                              !dz_1 = z_1½ - 0
    dz(2:nz) = zbnd(2:nz)-zbnd(1:nz-1)              !dz_i = z_i+½ - z_i-½
 
    dzmid(1:nz-1) = z(2:nz)-z(1:nz-1)               !dz_i+½ = z_i+1 - z_i

  end subroutine init_Zgrid

  !----------------------------------------------------------------------------
  !> code to test Zgrid routines in this module

  subroutine test_Zgrid(ionum)

    integer, intent(in) :: ionum    ! Unit number for output file
    integer :: i, im
    real, dimension(14 ) :: &
      ztest = (/1.0,2.0,4.0,8.0,16.0,32.0,64.0,100.0,&
                150.0,200.0,250.0,300.0,400.0,500.0/) 
      esx%zbnd = 0.0
      esx%zbnd(1:14) = ztest(:)

    call init_Zgrid()

    write(ionum,"(3a3,4a12)") "nz","n ","n-1","z(i)","zbnd(i)", "dz(i)", "dzmid(i)"
    do i = 1,  esx%nz
      write(ionum,"(3i3,4f12.3)") esx%nz, i, im, &
                                   esx%z(i), esx%zbnd(i), esx%dz(i), esx%dzmid(i)
    end do
    write(ionum,*) "===== done test ========="
    
  end subroutine test_Zgrid
  !----------------------------------------------------------------------------


end module esx_Zgrid

! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !
!DSX program tester
!DSX  use esx_Zgrid,  only : test_Zgrid ! TESTING only
!DSX  implicit none
!DSX  integer :: ionum
!DSX    open(newunit=ionum,file="TestingZgrid.txt")
!DSX    call  test_Zgrid(ionum)
!DSX    close(ionum)
!DSX end program tester
! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !
 
esx_Zveg.f90 xxxxxxxxxxxxxxxxxxxxxxxxxxx
  337  1331 11769 ../esx_Zveg.f90
 
!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!> MODULE esx_Zveg
!>   Definition of leaf area variables: nhVeg, dLAI(z), cumLAI(z)
!!   gsto, gns, PAR.
!!   LAI - conversion from JP matlab routines, May 2013. (minor changes)
!@author
!> David Simpson and Juha-Pekka Tuovinen
!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

module esx_Zveg
  use CheckStops, only: CheckStop ! between point values
  use esx_Variables, only: esx, Zveg, Loc
  use Io_Routines, only : writedata

  implicit none
  private

  public  :: config_Zveg         !> choose method and params
  public  :: init_Zveg           !> allocated Zveg variables
  public  :: def_leaf_profile    !> defines LAI using beta or other functions
  public  :: set1Dveg            !> time and z-dependent gleaf, PAR
  public  :: def_gleaf           !> defines conductances
  public ::  def_rad_prof
  public  :: test_Zveg           !> testing subroutine

  private :: beta                !> beta function

  !Aug 2013: modified from EMEP land_input type, hence more complex than needed
  !for ESX, so far... 
  !> Veg type looks after the scalar data associated with one land-cover
  !!  WARNING: Much confusion with values set in the LocalVariables array

  type, public :: Veg_t
     character(len=30) :: name    = "-"
     character(len=15) :: code    = "-"
     character(len=3)  :: type    = "-"   ! Ecocystem type, see headers
     character(len=5)  :: LPJtype = "-"   ! Simplified LPJ assignment
     real    ::  hveg_max = 0.0
     real    ::  hveg     = 0.0
     real    ::  dPerh    = 0.7    ! d/hveg
     real    ::  gMax     = 0.0  ! max. conductance, m/s
     real    ::  alpha    = 0.0  !

     character(len=15) :: LAI_method ="input"
     character(len=15) :: profile    ="uniform"
     real :: beta_a =10.0, beta_b = 4.0  !> beta parameters, default
     real :: canopy_bottom =0.5  !> If uniform canopy, fraction of hVeg
     real :: LAI, SGS = 100, EGS = 200            ! FAKE
     real    ::  Eiso = 0.0   ! Emission potential isoprene, ug/g/h
     real    ::  Emtl = 0.0   ! Emission potential m-terpenes, light
     real    ::  Emtp = 0.0   ! Emission potential m-terpenes, pool
  end type Veg_t
  type(Veg_t), public  :: Veg

  real, private, save :: pi        = 4*atan(1.0)
  real, private, save :: pi_div180 = 4*atan(1.0)/180.0

 contains
  !----------------------------------------------------------------------------
  !> config_Zveg chooses the method for setting LAI etc.
  !! values of the z array, hVeg, and LAI

  subroutine config_Zveg(io,writelog)
    integer, intent(in) :: io
    logical, intent(in) :: writelog 
    integer :: ilog

    namelist /esxVeg_config/ Veg
    rewind(io)
    read (io, nml=esxVeg_config)
    if(  writelog ) then
      open(newunit=ilog,file="LogConfig.Zveg")
      write(ilog,nml=esxVeg_config)
      close(ilog)
    end if
  end subroutine config_Zveg


  !----------------------------------------------------------------------------
  !> init_Zveg allocates the LAI-associated variables based upon the values of
  !! the z array, hVeg, and LAI. Should be called if veg LAI changes.

   subroutine init_Zveg()

    integer :: iz, nz, io
    real, pointer, dimension(:) :: dLAI, cumLAI

    nz = esx%nz
    dLAI => Zveg(1:nz)%dLAI
    cumLAI => Zveg(1:nz)%cumLAI

    dLAI = 0.0
    cumLAI = 0.0

    call def_leaf_profile(Veg%LAI,Veg%hVeg)

      !> Output LAI z-distribution
      open(newunit=io,file="LogLAIz.txt")
      write(io, "(a,5f7.2,i3)") "#Zveg:LAI,hveg,htrunk,a,b,nhVeg: " // &
         trim(veg%profile) , Veg%LAI,Veg%hveg,Veg%canopy_bottom, &
           Veg%beta_a, Veg%beta_b, esx%nhVeg
      write(io,"(a4,2a7,9a9)") "iz", "z", "zbnd", "dz", "dLAI", "cumLAI"
  
      do iz = esx%nhVeg, 1, -1
        write(io, "(i4,2f7.2,9f9.3)") &
         iz, esx%z(iz), esx%zbnd(iz), esx%dz(iz), dLAI(iz), cumLAI(iz)
      end do
      close(io)

   end subroutine init_Zveg

  !----------------------------------------------------------------------------
  ! Set1dveg updates vertical profiles of PAR and leaf conductance.

   subroutine Set1dVeg( printflag)
       logical, intent(in) :: printflag
       real :: sumPAR
       integer :: nv, nz
       logical :: daytime

       nz      = esx%nz
       nv      = esx%nhVeg
       sumPAR  = Loc%PARsun + Loc%PARshade   
       daytime = sumPAR > 1.0e-10

       Zveg(:)%PARz = sumPAR    ! above canopy (but not used!)

       Zveg(1:nv)%PARz =  def_rad_prof(sumPAR, Zveg(1:nv)%cumLAI, kRad=0.4, theta=60.0 )
   
       Zveg(1:nv)%gleaf =  def_gleaf( Zveg(1:nv)%PARz, Veg%gMax, Veg%alpha, nv, daytime)

       if( printflag ) then
          call writedata("LogPARngs",(/"  z", "PAR", " gs"/), esx%z(1:nz), &
             reshape( (/ Zveg(1:nz)%PARz, Zveg(1:nz)%gleaf /), (/ nz, 2 /) ) &
            ,"# Vegetation radiation and condutance profiles" )
       end if
         
       
   end subroutine Set1dveg

  !----------------------------------------------------------------------------

   subroutine def_leaf_profile(LAI,hVeg)
    real, intent(in)               :: LAI  &!! leaf area index (total, m2/m2)
                                         ,hVeg    !! vegetation height (m)

    real :: zPerh                  !> =z/h
    real :: fdiv                   ! hVeg*beta(a,b)
    integer :: iz, nz
    real :: a, b, zbelow, hTrunk=-999. , dzinside, sumLAI
    real, pointer, dimension(:) :: dLAI, cumLAI, z, dz, zbounds

    nz      = esx%nz
    z       => esx%z(1:nz)
    dz      => esx%dz(1:nz)
    zbounds => esx%zbnd(1:nz)
    dLAI    => Zveg(1:nz)%dLAI
    cumLAI  => Zveg(1:nz)%cumLAI

    dLAI=0.0 

    select case ( Veg%profile )
    case ( "uniform" ) 
      hTrunk = hVeg * Veg%canopy_bottom      ! 
      a = LAI/( hVeg - hTrunk )              ! LAI per unit z

      zbelow = 0.0                    
      esx%nhVeg  = -99

      ZULOOP: do  iz = 1, nz
         if( iz>1) zbelow = zbounds(iz-1)
         dzinside = 0.0
         if ( hTrunk >  zbounds(iz) ) then 
            cycle
         else if ( hVeg   <= zbounds(iz) ) then  ! canopy-top in last layer
            dzinside = hVeg-zbelow - max( hTrunk-zbelow, 0.0 )
            !print "(a,i4,8f9.2)", "Profiling h>ztop  ", iz, hTrunk, hVeg, &
            !    zbelow, zbounds(iz), hVeg-zbelow , hTrunk-zbelow, dzinside

            esx%nhVeg = iz  ! Found top layer. Will exit below

         else  
            dzinside = zbounds(iz) - max( hTrunk, zbelow ) 
            !print "(a,i4,8f9.2)", "Profiling isnide  ", iz, hTrunk, hVeg, zbelow, zbounds(iz), dzinside
         end if
         dLAI(iz) = dzinside * a / dz(iz)
         print "(a,i4,8f9.2)", "Profiling LAI: ", iz, hTrunk, hVeg, dzinside, dLAI(iz), sum(dLAI)
         if( esx%nhVeg > 0 )   exit
      end do ZULOOP
    
    case ( "beta" ) 
       a = Veg%beta_a
       b = Veg%beta_b
       fdiv = hVeg*beta(a,b)

       ZBLOOP: do  iz = 1, nz
         zPerh = z(iz)/hVeg
         if( zPerh <= 1.0 ) then

           dLAI(iz) = LAI*zPerh**(a-1.) * (1-zPerh)**(b-1.)/fdiv

           print "(a,i3,f6.1,3f12.4)", "dLAI ", iz, z(iz), zPerh, &
                  zPerh**(a-1.) * (1-zPerh)**(b-1.)/fdiv, dLAI(iz)
         else
           print "(a,i3,2f6.1,3f12.4)", "xLAI ", iz, z(iz), hVeg, &
              zPerh, sum( dLAI(:)*dz(1:nz) )
           exit ZBLOOP 
         end if

       end do ZBLOOP

       esx%nhVeg = iz

     ! With beta, we need to normalise to get LAI = cumLAI(1).  

       sumLAI = dot_product ( dLAI(1:nz), dz(1:nz) ) 
       dLAI(:) = dLAI(:) * LAI/ sumLAI


    case default
       call CheckStop(.true., "esx_Zveg:unknown profile method: "//trim(Veg%profile))
    end select

    do iz = esx%nhVeg, 1, -1
      cumLAI(iz) = dot_product ( dLAI(iz:nz), dz(iz:nz) )
    end do

    call CheckStop(any( cumLAI<0.0)  , "esx_Zveg:Problems cumLAI: "//trim(Veg%profile))
    call CheckStop(any(   dLAI<0.0)  , "esx_Zveg:Problems cumLAI: "//trim(Veg%profile))

   end subroutine def_leaf_profile
  
  !----------------------------------------------------------------------------
  !> def_gleaf  defines stomatal and non-stomatal conductance
  !! values of the z array, hVeg, and LAI.
  !! Very simple!!! To be replaced by DO3SE options..

    function def_gleaf(PARz, gMax, alpha, nhVeg, daytime) result(gleaf)
    real, dimension(:), intent(in) :: PARz
    real, intent(in) :: gMax     &!>  Max conductance m/s
                       ,alpha     !>  light response coefficient
    integer, intent(in) :: nhVeg
    logical, intent(in) :: daytime

    real, dimension(size(PARz)) :: gleaf

    gleaf = 0.0

    if ( daytime  ) gleaf(1:nhVeg) = gMax * ( 1.-exp(-alpha*PARz(1:nhVeg) ))

   end function def_gleaf
  !----------------------------------------------------------------------------
  !> Simple radiation profile in canopy
  !> @param[in]   PAR, kRad, theta
  !> @param[out]  PARz

   function def_rad_prof(I, cumLAIz, kRad, theta ) result(Iz)

    real, intent(in) :: I      &!> W/m2
                       ,kRad   &!! radiation extinction coefficient   
                       ,theta   !! angle (degrees)
    real, dimension(:), intent(in) :: cumLAIz    !> m2/m2

    real, dimension(size(cumLAIz)) :: Iz   !> W/m2

      Iz = I*exp(-kRad*cumLAIz/cos(theta*pi_div180))

   end function def_rad_prof

  !----------------------------------------------------------------------------
  !> beta function, derived using fortran gamma function. (see wikipedia)
  !  (Might move to Functions at later stage, but now just used here)

   function beta(x,y) result(b)
    real, intent(in) :: x, y
    real :: b
    b = gamma(x) * gamma(y)/gamma(x+y)
   end function beta
  !----------------------------------------------------------------------------
  !> testing code. Just call to run init_Zveg with some typical values.

  subroutine test_Zveg()
    real :: PAR = 400.0

    !call SetLeafArea(103) !> gets LAI for day 183
    call init_Zveg()

    Zveg%PARz = def_rad_prof(PAR, Zveg%cumLAI, kRad=0.4, theta=30.0 )
    Zveg%gleaf=  def_gleaf(Zveg%PARz,gMax=0.02,alpha=0.01,nhVeg=9,daytime=.true.) ! io present triggers debug ro screen
    print *, "GLEAF ", maxval(Zveg%gsto)
    
  end subroutine test_Zveg
  !----------------------------------------------------------------------------
end module esx_Zveg

!TEST PROG AT END
!----------------------------------------------------------------------------
!SKIP! SetLeafArea gets LAI
!SKIP! Skip for now. Probably LAI should be set outisde ESX.
!SKIP
!SKIP!subroutine SetLeafArea(jday)
!SKIP!  integer, intent(in) :: jday
!SKIP!  
!SKIP!
!SKIP!    print *, "SetLeafArea ",  jday, Veg
!SKIP!    if ( Veg%LAI_method=="EMEP-latitude" ) then
!SKIP!      ! keys = max min DSGS  ESGS
!SKIP!      Veg%LAI = plf_value(reshape((/ real :: &
!SKIP!      &  Veg%SGS, Veg%LAI_vals(2),  & !min
!SKIP!      &  Veg%SGS + 30, Veg%LAI_vals(1), &
!SKIP!      &  Veg%EGS, Veg%LAI_vals(1) &
!SKIP!      &  /), (/2, 3/)), real(jday, dp))
!SKIP!    end if
!SKIP!   print *, "SET LEAF AREA ", jday, Veg%LAI
!SKIP!       
!SKIP!  end subroutine SetLeafArea
! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !
!UNCOMMENT TO TEST JUST THIS MODULE:
!DSX program tester
!DSX   use esx_Zgrid, only : init_Zgrid, test_Zgrid
!DSX   use esx_Zveg,  only : test_Zveg, config_Zveg
!DSX   integer :: ionum
!DSX 
!DSX 
!DSX    open(newunit=ionum,file="config_esx.nml")
!DSX    call config_Zveg(ionum,writelog=.true.)
!DSX    close(ionum)
!DSX
!   If file wanted, use other ionum for TestingLAI.txt output
!
!DSX   open(newunit=ionum,file="TestingLAI.txt")
!DSX    call  test_Zgrid(ionum) 
!DSX    call  test_Zveg() 
!DSX 
!DSX   close(ionum)
!DSX end program tester
! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !
 
esx_Zmet.f90 xxxxxxxxxxxxxxxxxxxxxxxxxxx
 182  665 5754 ../esx_Zmet.f90
 
!>  MODULE esx_Zmet
!!
!!  Definition of meteorology for z-layers
!!  We assign some initial values to simplify testing 
!   (Can/should be reset by real programmes!)

module esx_Zmet
  use CheckStops,    only: CheckStop
  use Io_Routines,   only: writedata
  use KeyValueTypes, only: KeyValue, KeyValReal
  use esx_Variables, only: L=> loc, esx, Zmet
  use esx_Zveg, only: Veg
  use Kz_ml

!QUERY??  use LocalVariables, only: L

  implicit none
  private

  public ::  init_Zmet  ! allocates arrays, sets initial(fake) values
  public ::  def_kz
  public ::  print_Kz
  public ::  test_Zmet  ! 
  !SKIP  public ::  config_Zmet  !  Not needed?

  logical, public, save :: first_call = .true.


 contains

  !----------------------------------------------------------------------------
  !> init_Zmet - mainly for testing. Initialises some met from local surface
  !! data.

  subroutine init_Zmet()
    integer :: nz
    nz = esx%nz

   !> Initialise for test

    if ( Zmet(1)%tzK < 1 )   then ! Assume nothing set.
      print "(a,i4, 2f7.2,es10.3)", "INIT_ZMET from Local, t,rh,p =>", &
        nz, L%t2,L%rh,L%psurf
      Zmet(1:nz)%tzK = L%t2   
      Zmet(1:nz)%rh  = L%rh
      Zmet(1:nz)%Pa  = L%psurf
    end if

    call def_Kz( esx%Kz_method, esx%Kz_kwargs )

  end subroutine init_Zmet

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!> def_kz calculates Kz values for given z-levels.
!! A variety of methods are available, with parameters provided through
!! the key-word argument methodology
 
subroutine def_Kz(KzMethod, kwargs)

  character(len=*), intent(in) :: KzMethod
  type(KeyValReal), dimension(:) :: kwargs
  real :: za, Ka, n, kappa = 0.4   ! CHANGE kappa later
  real, pointer, dimension(:) :: zlevs

  
  zlevs => esx%zbnd

  if( KzMethod == "constant" ) then
     print *, "KEYVALS", kwargs(1)
     Zmet%Kz = KeyValue( kwargs(1:1), "const" )

  else if( KzMethod == "power" ) then !test case
    za = KeyValue( kwargs, "za" )
    Ka = KeyValue( kwargs, "Ka" )
    n  = KeyValue( kwargs, "n" )
    Zmet%Kz =  def_kz_pow(zlevs, za, Ka, n )

  else if( KzMethod == "Leuning" ) then !test case
    call CheckStop( L%hsl < 0.0 , "ERROR: loc%hsl not set" )
    za = KeyValue( kwargs, "za" )
    Ka = KeyValue( kwargs, "Ka" )
    n  = KeyValue( kwargs, "n" )
    Zmet%Kz = def_Kz_inc(zlevs,L%uStar,Veg%hVeg,L%hSL,L%invL,kappa,Veg%dPerh)

  end if

  call print_Kz()

end subroutine def_kz

!----------------------------------------------------------------------------
!> print_Kz provides neat table of Kz values.
!! Can be called with ionum=6 to get standard output, otherwise LogKz.txt.
!! Assumed to only be called once, otherwise LogKz.txt overwritten (?)

 subroutine print_Kz()
   character(len=100) :: header
   integer :: nz
   header = "Kz method = "// trim(esx%Kz_method)

   ! need to reshape 1-D arrays into 2-D for writedata:

   nz = esx%nz
   call writedata("LogKz", &
     (/ "z    ", "dz   ", "dzmid","zbnd ", "Kz   ", "T(K) " /) & 
        ,esx%z(1:nz)   & !coords
        ,reshape( (/ esx%dz(1:nz), esx%dzmid(1:nz), &
                     esx%zbnd(1:nz), Zmet(1:nz)%Kz, Zmet(1:nz)%tzK /), (/ nz, 5 /) ),&
      header )

 end subroutine  print_Kz
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  !----------------------------------------------------------------------------
  !> Simple test. Not much should go wrong though (but be careful with z as
  !! mid-point or grid boundary)

  subroutine test_zmet(ionum)
    integer, intent(in) :: ionum    ! Unit number for output file
    real, dimension(5) :: ztest = (/1.0, 4.0, 8.0, 16.0, 100.0 /)
    integer :: iz
    esx%nz = 5

    call init_Zmet()

    write(ionum,"(a)") "Test Met nz=", size(ztest)
    do iz = 1, size(ztest)
      write(ionum,"(a,i3,f6.1,4f12.3)") "TestMet", iz,ztest(iz),Zmet(iz)%tzK, Zmet(iz)%rh,Zmet(iz)%Pa
    end do
    call  def_Kz( esx%Kz_method, esx%Kz_kwargs)
    call  print_Kz() 
  end subroutine test_Zmet
  !----------------------------------------------------------------------------
end module esx_Zmet

!NB: TESTING PROG AT END IF WANTED
!SKIP  !> config_Zmet 
!SKIP
!SKIP  subroutine config_Zmet(io,writelog)
!SKIP    integer, intent(in) :: io
!SKIP    logical, intent(in) :: writelog
!SKIP    integer :: ilog
!SKIP
!SKIP    namelist /esxMeteo_config/Zmet
!SKIP    print *, "INTO ZMET===================================="
!SKIP    rewind(io)
!SKIP    read (io, nml=esxMeteo_config)
!SKIP    if(  writelog ) then
!SKIP      open(newunit=ilog,file="LogConfig.Zmet")
!SKIP      print *, "CONFIG ZMET====================================", ilog
!SKIP      write(ilog,"(a)") "CONFIG ZMET===================================="
!SKIP      write(ilog,nml=esxMeteo_config)
!SKIP      write(*,nml=esxMeteo_config)
!SKIP      close(ilog)
!SKIP    end if
!SKIP  end subroutine config_Zmet

!UNCOMMENT TO TEST JUST THIS MODULE:
!DSX program tester
!DSX   use LocalVariables, only : L
!DSX   use esx_Zgrid, only : init_Zgrid, test_Zgrid
!DSX   use esx_Zmet,  only : test_Zmet, config_Zmet, init_Zmet
!DSX   integer :: ionum
!DSX    
!DSX    ! Some initial values of ambient temperature
!DSX    L%t2 = 298.0; L%psurf=1.0e5; L%rh=0.6
!DSX    open(newunit=ionum,file="config_esx.nml")
!DSX    call config_Zmet(ionum,writelog=.false.)
!DSX    close(ionum)
!DSX  print *, "DONE CONFIG"
!DSX
!   If file wanted, use other ionum for TestingMet.txt output
!
!DSX   open(newunit=ionum,file="TestingMet.txt")
!DSX    call  test_Zgrid(ionum) 
!DSX    call  init_Zmet() 
!DSX    call  test_Zmet(ionum) 
!DSX 
!DSX   close(ionum)
!DSX end program tester
! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !
                                                               
 
esx_Zchem.f90 xxxxxxxxxxxxxxxxxxxxxxxxxxx
 228 1072 8275 ../esx_Zchem.f90
 
 module esx_Zchem
  use AllocInits, only : AllocInit
  use CheckStops, only : CheckStop
  use ChemSpecs, only : species, define_chemicals, nspec => NSPEC_TOT
  use esx_Variables, only:  esx, Zmet
  use SmallUtils, only: find_index, find_indices, NOT_FOUND

  implicit none
  private

  public :: init_Zchem
  public :: Alloc1Dchem       !> Sets up arrays of dimension nspec x nz
  private :: Config_Zchem


   logical, public, save :: first_call = .true.
   integer, public, save :: ncalls     =      0
   integer, private, parameter :: TXTLEN =   20

  !> Configuration of chemical boundary and initial conditions (BIC)
  !! =========================================================================
  !! Typically, we only need to specify BICs for long-lived species (advected). 

   integer, private, parameter :: MAXBICS = 8  !> Max. No. records with BICs

   type, private :: BIC_t
     character(len=TXTLEN) :: name = "-"
     real :: conc = 0.0                !! concs in ppb
     integer :: z1=0, z2=0             !! height level range for this record
   end type BIC_t

   ! Some more complex code for BIC moved to end (SKIP1)


  !! We store both types of initialisation for configZchem:

   type(BIC_t),    dimension(MAXBICS) :: BIC = BIC_t()


   !> 1-D chemical variables

   real, public, save, allocatable, dimension(:,:) :: & ! dims: nspec x nz
      rct               & !> chemical rate coeffs.  molec/cm3/s
     ,rcemis(:,:)       & !> Emissions rate coeff.  molec/cm3/s
     ,xChem(:,:)        & !> concentrations, molec/cm3
     ,DChem(:,:)          !> chemical tendency, molec/cm3/s

 
  contains
  !--------------------------------------------------------------------------!
  subroutine init_zchem(ioconfig, debug_level) !!, errmsg)
    integer, intent(in) :: ioconfig
    integer, intent(in) ::  debug_level  ! 0, 1 or 2
!    character(len=*), intent(inout) :: errmsg

   !=========================================
    call define_chemicals()   ! Sets species
   !=========================================

    call Alloc1Dchem(esx%nz, debug_level = 1)

    call Config_Zchem(ioconfig, debug_level ) !> Mainly boundary conditions

  end subroutine init_Zchem
  !--------------------------------------------------------------------------!
   subroutine Alloc1Dchem(nz, debug_level)
    integer, intent(in) :: nz, debug_level

    !> We need to re-allocate if changes in array size, e.g. moving from
    !! EMEP to ESX

      if( debug_level > 0 ) print *, "ALLOCATE xCHEM?? ", nspec, nz, size(xChem, 1)
      if ( allocated( xChem) ) then
        if ( size( xChem, 1) /= nz ) deallocate(xChem, Dchem, rcemis, rct )
      end if

      if ( .not. allocated( xChem) ) then

          if( debug_level > 0 ) print *, "ALLOCATES xCHEM ", nspec, nz
          call AllocInit( xChem,  0.0, nspec, nz, "set1D:xChem")
          call AllocInit( Dchem,  0.0, nspec, nz, "set1D:Dchem")
          call AllocInit( rcemis, 0.0, nspec, nz, "set1D:rcemis")
          call AllocInit( rct,    0.0, nspec, nz, "set1D:rct")

      end if

  end subroutine Alloc1Dchem

  !--------------------------------------------------------------------------!
  !> The Config_Zchem routine is mainly to set initial and
  !! boundary conditions. We use text strings for compound names,

  subroutine Config_Zchem(ioconfig, debug_level)

    integer, intent(in) :: ioconfig
    integer, intent(in) ::  debug_level  ! 0, 1 or 2
    integer :: i, ilog=0, ispec, iz, iz1, iz2, nbic
    integer, dimension(MAXBICS) ::  bic_list = 0
    real :: ppb = 2.55e10  !! TMP fix later with real factor
    namelist /chem_config/BIC

    print *, "INTO ZCHEM==================================="
    rewind(ioconfig)
    read (ioconfig, nml=chem_config)
    if(  debug_level > 1 ) then
      open(newunit=ilog,file="LogConfig.Zchem")
      !A28 print *, "CONFIG chem ================================", ilog
      write(ilog,"(a)") "CONFIG chem ================================"
      write(ilog,nml=chem_config)
      !A28 write(*,nml=chem_config)
    end if

   !> Assign initial xChem values. Use simple approx for ppb just now.
   !!  Fix later !!
   !! ( Can use z2 = 999 to ensure top of domain )

    nbic = 0 

    BICLOOP : do i = 1,  MAXBICS

      if ( BIC(i)%name == "-" ) exit
      ispec = find_index( BIC(i)%name, species(:)%name )
      if ( ispec < 1 ) then
        if(debug_level>0) write(*,*) "Zchem:BIC WARNING, BIC species not in mechanism:"&
                  //trim( BIC(i)%name)
        cycle BICLOOP
      end if

      if ( find_index( ispec, bic_list ) == NOT_FOUND) then ! new species
        nbic = nbic + 1
        bic_list(nbic ) = ispec
      end if

      iz1 = BIC(i)%z1
      iz2 = min ( BIC(i)%z2, esx%nz )

      do iz = iz1, iz2
         xChem( ispec, iz ) = BIC(i)%conc * ppb
         if ( debug_level >1 ) write(ilog,"(a,3i4,f8.2)") "BIC: xCHEM", &
              i, ispec, iz, xChem( ispec, iz )/ppb
      end do

      if( debug_level >0 ) write(*, "(a,2i4,1x,a,2i3,g12.3)")  "BIC:SET ", &
         i, ispec, trim( BIC(i)%name ), iz1, iz2, BIC(i)%conc
    end do BICLOOP

    if(  ilog /= 0 ) close(ilog)

    write(*,"(a,/,a,a3,4x,99a10)") "ZChem_BIC Summary ---------------------",&
     "ZChem:BIC FINAL", "iz",  species(bic_list(1:nbic))%name 
    do iz = esx%nz, 1, -1
      write(*,"(a,i3,99f10.3)") "BIC FINAL", iz, xChem( bic_list(1:nbic), iz)/ppb
    end do


   ! Some more complex code for BIC moved to end (SKIP2)
     
  end subroutine Config_Zchem

  !--------------------------------------------------------------------------!
 end module esx_Zchem

!-----------------
!SKIP1
! Skip this fancier stuff for now. DiffSpecs now in esx_Variables
!  !> Configuration -  species affected by turbulent diffusion (ie by Kz)
!  !! =========================================================================
!  !! We have two  main options
!  !!   (a) "list" - specify a list of species names
!  !!   (b) "range" - specify a range of indices 
!  !! The latter is probably safer for large chemical schemes, and assumes that
!  !! the species in CM_ChemSpecs are ordered in some kind of lifetime scale. 
!  !! Typically we can skip all radicals, and also compounds like CO, CH4 etc.
!  !! (needs to be investigated)
!
!   integer, private, parameter :: MAXDIFF = 10 !> Max. No. species for diffusion
!   type, private :: KzSpec_t
!     character(len=TXTLEN)                   :: method = "list" !! list or range
!     character(len=TXTLEN), dimension(nspec) :: name = "-"
!     integer :: nesx = 0  !!  number of diffusing species for ESX runs
!     integer,  dimension(nspec) :: index = -1  !! index from species array
!   end type KzSpec_t
!-----------------
!SKIP2
!Skip this fancier stuff for now. DiffSpecs now in esx_Variables.
!   !> Calculate species for diffusion calcs.
!
!    associate ( list => Zchem%kzSpecs%name )
!    !list(:) = Zchem%kzSpecs%name(:) ! Copy list, and write back into KzSpecs%name

!    Zchem%KzSpecs%nesx = 0 !count( find_indices ( list(1:ispec), species(:)%name ) > 0 )

!    if ( Zchem%KzSpecs%method == "list" ) then

!      !sometimes the namelist will have species which are not found in the
!      ! current mechanism. We skip these

!      do i = 1, LenArray( list(:), "-" )   
!         ispec = find_index( list(i), species(:)%name  )
!         if ( ispec > 0 ) then
!           esx%nKzSpecs = esx%nKzSpecs + 1
!           Zchem%KzSpecs%index( esx%nKzSpecs ) = ispec
!DANGER            Zchem%KzSpecs%name( i ) = 
!         end if
!      end do
!
!    elseif ( Zchem%KzSpecs%method == "range" ) then

!      ispec1 = find_index( list(1), species(:)%name  )
!      ispec2 = find_index( list(2), species(:)%name  )
!      if( ispec2 < ispec1 ) call CheckStop(.true., "Zchem:KzSpecs:range NEG!")

!      do ispec = ispec1, ispec2
!           esx%nKzSpecs = esx%nKzSpecs + 1
!           Zchem%KzSpecs%index( esx%nKzSpecs ) = ispec
!           !DANGER Zchem%KzSpecs%name( esx%nKzSpecs ) = ispec
!      end do

!    else
!      call CheckStop(.true., "Zchem:KzSpecs:Incorrect method:"//&
!                     trim(Zchem%KzSpecs%method)) 
!    end if
!
!    do ispec = 1, esx%nKzSpecs
!       i = Zchem%KzSpecs%index( ispec )
!       write(*,*)"ESX KzSpecs ", ispec, i , trim(species(i)%name)
!    end do
!   end associate ! list
 
Kz_ml.f90 xxxxxxxxxxxxxxxxxxxxxxxxxxx
 121  458 3470 ../Kz_ml.f90
 
! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !
!> Provides Kz from various methods
!! Main complexity is those different methods, which we deal with using
!! key-word arguments, e.g. if KzMethod constant, we need one argument
!! but if KzMethod is power-law we need more. 

module Kz_ml


  implicit none

  public :: def_kz_nsl
  public :: def_kz_inc
  public :: def_kz_pow
  private :: non_rect_hyperbola
  
contains
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function def_kz_nsl(z,nsl,ustar) result(K)
 !  neutral Kz in SL, constant above
  real, intent(in), dimension(:) :: z
  real, intent(in) ::  ustar
  integer, intent(in) :: nsl
  real, dimension(size(z)) :: K
  real :: kappa = 0.4
 
  K = kappa*ustar*z
  K = min(K,K(nsl))  !QUERY???

end function def_kz_nsl

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!> Leuning et al AFM 2000 Kz method
!! NB - stability correction (use of 1/L) not implemented

function def_Kz_inc(z,uStar,hVeg,hSL,invL,kappa,dPerh) result (Kz)
 !  neutral Kz in SL, constant above
  real, intent(in), dimension(:) :: z   !> heights at which Kz calculated
  real, intent(in) ::  &
     ustar, hVeg       &   !> Obvious?
    ,hsl               &   !> Height surface layer (m) and  1/L
    ,invL              &   !> 1/L (L=Obukhov length, m) NB: no stability corr. yet
    ,dPerh                 !> = d/hVeg
  real, intent(in) :: kappa !> von Karman constant

  real, dimension(size(z)) :: Kz   ! Resulting Kz
  real, dimension(size(z)) :: zPerh, fac, sigma_w, tau_L, Krsl
  real :: d
  integer :: nsl, nz, k

 !> Leuning equation params
  real, parameter :: ZH0 = 0.8, ZH1 = 0.25  &
    ,a0 = 0.850, b0 = 1.25, c0 = 0.98, d0 = -1, e = 0.2, f = 1.5 &
    ,a1 = 0.256, b1 = 0.40, c1 = 0.98, d1 =  1, s1 = 0.8  &
    ,a2 = 0.850, b2 = 0.41, c2 = 0.98, d2 = -1, s2 = 4


   d = dPerh*hVeg
   nsl = count( z < hsl )
   nz = size(z)
   zPerh(:) = z(:)/hVeg
   print *, "ZPERH ", nsl, zPerh

   !> From: Leuning et al., AFM, 2000 %%%
   !> sigma_w:

   where ( zPerh < ZH0)
     fac = e*exp(f*zPerh)
   elsewhere
     fac = non_rect_hyperbola(zPerh,a0,b0,c0,d0)
   end where

   sigma_w = fac*uStar

  !> tau_L:
   where ( zPerh < ZH1 )
     fac = non_rect_hyperbola(s2*zPerh,a2,b2,c2,d2)
   elsewhere
     fac = non_rect_hyperbola(zPerh-s1,a1,b1,c1,d1)
   end where

   tau_L = fac*hVeg/uStar

   Krsl = sigma_w**2 * tau_L     !! in and just above vegetation 
   Kz = kappa*uStar*(z-d)        !! M-O similarity theory

   do k = 1, nsl                 !! QUERY? Not sure of matlab code
     print *, "KLEU ", k, nsl,  Kz(k), Krsl(k) 
     Kz(k) = max(Kz(k),Krsl(k))             !! match
   end do

   Kz(nsl+1:nz) = maxval( Kz(1:nsl) )  !> constant above SL

end function def_Kz_inc

!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!>  non-rectangular hyperbola

elemental function non_rect_hyperbola(x,a,b,c,d) result(y)
  real, intent(in) :: x,a,b,c,d
  real :: y
  real :: dum

  dum = a*x + b;
  y = (dum + d*sqrt(dum**2 - 4*a*b*c*x))/(2*c);
end function non_rect_hyperbola



!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
elemental function def_kz_pow(z,za,Ka,n) result(K)
 ! power law K(z) = Ka*(z/za)^n
  real, intent(in) :: z,za,Ka,n
  real :: K

  K = Ka*(z/za)**n;

end function def_kz_pow
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
end module Kz_ml
 
esx_ZdiffSolver.f90 xxxxxxxxxxxxxxxxxxxxxxxxxxx
 196  789 6223 ../esx_ZdiffSolver.f90
 
! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !
!> MODULE
!! Solves vertical diffusion in ESX system
!@author
!> Juha-Pekka Tuovinen and David Simpson
!> 2013
! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !

module esx_ZdiffSolver
  use esx_Variables, only: esx, Zmet
  implicit none
  private

  public  :: ZdiffSolver
  private :: inv_3diag

contains

  subroutine ZdiffSolver(nz,dti,Vd,Ve,D,E,Fb,Ft,concn,fixedBC,debug_level)
   integer, intent(in) :: nz
   real, intent(in) :: &
      dti     &! time step wanted [s]
     ,Vd      &! deposition velocity [m/s]
     ,Ve      &! escape velocity [m/s]
     ,Fb      &! bottom boundary flux [g/(m2s)] (+ = down)
     ,Ft       ! top    boundary flux [g/(m2s)] (+ = up)

   real, dimension(nz), intent(in) :: &
      D        &! 1st order source/sink coefficient [1/s]     = S1
     ,E         ! 0th order source/sink coefficient [g/(m3s)] = S0

   real, dimension(nz), intent(inout) :: concn
   real, dimension(nz) :: old
   logical, intent(in) :: fixedBC  !  fixed top boundary conc
   integer, intent(in) ::  debug_level  ! 0, 1 or 2

   real, dimension(nz) :: &
      R               &! 
     ,Ua, La, Ma      &! 
     ,U               &!upper diagonal,  U(1:nz+1), U(nz+1)=0
     ,L               &!lower diagonal,  L(1:nz+1), L(1)=0
     ,M               !main diagonal,   M(1:nz+1)

   real ::   Vda, Vea, Fba, Fta, stabtest, dt, dtstab
   integer :: j, k,  nz1, nz2
   integer :: nt  ! number of time steps in C-N method, to be calculated
   logical, save :: first_call = .true.

  ! weight of (j+1)th and jth time step (Crank-Nicolson, if wj1=0.5)
   real, parameter ::  wj1 = 0.5, wj = 1-wj1  

   real, pointer, dimension(:) :: z, dz, dzmid, Kz

   z     => esx%z(1:nz)
   dz    => esx%dz(1:nz)
   dzmid => esx%dzmid(1:nz)
   Kz    => Zmet(1:nz)%Kz

   nz1 = nz -1  ! Number of mid layers, e.g. for  Kz
   nz2 = nz -2  ! Used in rhs calculations

  !> Stability check for ZdiffSolver time-step
  !! To prevent oscillations, we need  K.dt/(dz**2) < 0.5, or dt < 0.5 dz**2/K.
  !
   if ( dt > tiny(dt) ) dt = min( dt, dti )  !> Selects shortest dt
   dtstab = 0.5*minval( dz(1:nz1)**2 / Kz(1:nz1) )
   dt = min( esx%dt_Zdiff, dtstab ) 
   nt = ceiling( dti/dt )
   nt = max(1, nt)
   dt = dti/nt

   if( first_call .and. debug_level >0 ) then
     print "(a,3g12.3,a,g12.3,i6)", "ZdiffDts:", &
       dti,dtstab,esx%dt_Zdiff, " => dt, nt", dt, nt

     if( debug_level>1 ) then !! Show where the stability criteria max is
       print "(a,i6,20es10.3)", "debug-Zdiff start:",nt, dt
       print "(a,a6,20a10)", "Zdiff start:","k", "%z(k)",  "dzmid(k)",&
          "dz(k)", "D(k)", "E(k)", "K(k)", "concn(k)", "Crit."

       do k =  nz1, 1, -1
         stabtest =  Kz(k) * dti/dz(k)**2
         print "(a,i6,3f8.2,20es10.2)", "Kdiff start:",k, z(k+1), dzmid(k), &
          dz(k), D(k), E(k), Kz(k), concn(k),  stabtest
       end do
     end if
   end if

 !>  start solution

  Ua(1:nz1)   = Kz(1:nz1)*dt/(dzmid(1:nz1)*dz(1:nz1))
  Ua(nz)=0
  La(2:nz)     = Kz(1:nz1)*dt/(dzmid(1:nz1)*dz(2:nz))
  La(1)=0
  Ma(1:nz)     = D(1:nz)*dt
  Vda = Vd*dt/dz(1)
  Vea = Ve*dt/dz(nz)
  Fba = Fb/ dz(1)
  Fta = Ft/ dz(nz)

 !> 3-diagonal matrix
    U = -wj1*Ua             !upper diagonal,  U(1:nz), U(nz)=0
    L = -wj1*La             !lower diagonal,  L(1:nz), L(1)=0
    M = 1 - U - L - wj1*Ma  !main diagonal,   M(1:nz)
    M(1)  = M(1) + wj1*Vda 
    M(nz) = M(nz) + wj1*Vea

    if ( fixedBC ) then
        L(nz) = 0.0 ! SCOPE CHANGED. kdiff had n+1 for both
        M(nz) = 1.0
    end if

 !> ---start time integration---
    do  j = 1, nt
       !>>>right-hand side:    
       R(1)    = wj*Ua(1)                        * concn(2)      +&
                 (1 - wj*(Ua(1) + Vda - Ma(1)))  * concn(1)      +&
                 ( E(1) -Fba )  *dt
       R(2:nz1) = wj*Ua(2:nz1)                                * concn(3:nz) +&
                 (1 - wj*(Ua(2:nz1) - Ma(2:nz1) + La(2:nz1))) * concn(2:nz1) +&
                 wj*La(2:nz1)                                 * concn(1:nz2) +&
                 E(2:nz1)*dt
       R(nz) = (1 - wj*(La(nz) + Vea - Ma(nz)))  * concn(nz)   +&
                 wj*La(nz)                       * concn(nz1)  +&
                 ( E(nz) - Fta ) *dt
       !<<

       if ( fixedBC ) R(nz) = concn(nz) ! FIXED top boundary concentration

       if( debug_level>0 ) old(:) = concn(:)

       concn = inv_3diag(U,M,L,R)  !solve c(j+1)

       if( debug_level>1 ) then
        print "(a,f12.3)", "Kdiff-changes ------------------------------ t=" , esx%Time
        do k =1, nz
          print "(a,2i3,20es12.3)", "Kdiff-changes ", j,k,  &
                old(k), concn(k), R(k), Ua(k), E(k), Ma(k)
        end do
       end if

     if ( any( concn < 0.0) ) then
       print *, "NEG!!! ", j
       do k =  nz, 1, -1
         print "(a,i6,20es10.2)", "Kdiff fail!:",k, z(k+1), dzmid(k), &
        dz(k), D(k), E(k), Kz(k), concn(k),  stabtest
       end do
       stop "NEG!!!"
     end if

     !>>testing:
       ! mass(j) = sum(concn*dz)   !   int_mass(concn,dz);
       !anmass(j) = an_sol_m1(j*dt,z,Ka,Vd);
       !anmass(j) = exp(D(1)*j*dt); %D(z)=D(1), c(z)=const%
       !<<<

       first_call = .false.

    end do
    !---end time integration---


end subroutine ZdiffSolver
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function inv_3diag(U,M,L,R) result(x)
  !x = inv_3diag(U,M,L,R)
  ! U(1:n) = upper diagonal, U(n)=0
  ! M(1:n) = main diagonal
  ! L(1:n) = lower diagonal, L(1)=0
  ! R(1:n) = right-hand side
 
  real, intent(in), dimension(:) :: U, M, L, R
  real, dimension(size(U)) :: x
  real, dimension(size(U)) :: A, B
  real :: div
  integer :: n, i

  n = size(U);
 
  A(1) = -U(1)/M(1)
  B(1) =  R(1)/M(1)
  do  i = 2, n
    div = M(i) + L(i)*A(i-1)
    A(i) = -U(i)/div   !A(n) not used
    B(i) = (R(i) - L(i)*B(i-1))/div
  end do
 
  x(n) = B(n);
  do i = n-1,1, -1 ! QUERY
     x(i) = A(i)*x(i+1) + B(i)
  end do
end function inv_3diag
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
end module esx_ZdiffSolver

! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !
 
esx_ChemRun.f90 xxxxxxxxxxxxxxxxxxxxxxxxxxx
  66  267 2277 ../esx_ChemRun.f90
 
module esx_ChemRun
  use ChemSpecs
  use ChemRates
  use ChemSolver
  use DefPhotolysis, only : setphotorates, rcphot, IDNO2
  use esx_Variables, only: esx, Zmet
  use esx_Zchem, only : Alloc1dchem, xChem, Dchem, rct  
  use Met1D  !, only : Set1Dmet  !> sets t, h2o etc from ESX variables

  implicit none
  private

  public :: ChemRun

  contains
  !-------------------------------------------------------------------------!
   subroutine ChemRun( dtchem, debug_level )
      real,    intent(in) :: dtchem
      integer, intent(in) :: debug_level
      integer :: i, k, nz
      integer, parameter ::  NOUT = 10 ! for debug output, Max NSPEC_TOT
      logical, save :: first_call = .true.
      real :: ppb
      real :: fakenoon = 12*3600.0 ! for testing photorates only

      ppb = 1.0e9/Zmet(1)%M ! Output only

      if( debug_level > 0 .and. first_call) then
        write(*,"(a,2es12.2)") "CHDBG M, ppb ", Zmet(1)%M, ppb
        write(*,"(a,a7,20a8)") "CHDBG", "Time ", (species(i)%name, i=1, NOUT)
        write(*,"(a,f6.0,20es8.1)") "CHDBG", 0.0, (xChem(i,1)*ppb, i=1,NOUT)
      end if

      nz=esx%nz
      call Set1Dmet( nz, Zmet )
      !A28 BUG. Was done if( first_call ) call Alloc1Dchem( nz, debug_level )
      call setphotorates( fakenoon, debug_level)
      call setchemrates( debug_level )

      if ( first_call ) then !.and. if ( debug_level > 0 ) then 
        write(*,*) "DEBUG RCT sizes: ", size(temp), size(rct(1,:))
        do k = 1, size(temp)
          write (*,"(a,i3,2f6.1,3es10.3,2x,50es10.2)") "DEBUG RCT:", k, &
                TEMP(k), 1.0/TINV(k), M(k), O2(k), H2O(k), rct(1:4,k), rcphot(IDNO2)
        end do
      end if


    !> Do chemistry now, layer by layer for one dt_advec

      if(first_call) print *, "ChemRun xChem Dims; nspec,nz=",  size(xChem,dim=1), size(xChem,dim=2)
      write(*,"(a,f6.0,20es8.1)") "CHDBG", 999. , (xChem(i,1)*ppb, i=1,NOUT)

      do k = 1, Nz
          call chemsolve( dtchem, xChem(:,k),Dchem(:,k),debug_level )
      end do ! k

      if( debug_level > 1 ) write(*,"(a,f6.0,20es8.1)") "CHDBG", &
          esx%Time, (xChem(i,1)*ppb, i=1, NOUT)
          !esx%Time, (xChem( esx%OutSpecs(i)%int ,1)*ppb, i=1, NOUT)

      first_call = .false.
     
   end subroutine ChemRun

end module esx_ChemRun
 
